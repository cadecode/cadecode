<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java 集合与容器类 | CadeCode</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/meta/favicon.ico">
    <meta name="description" content="集合与容器类是 Java 开发过程中的重要内容，是由接口、抽象类、派生类及相关算法组成的体系">
    <link rel="preload" href="/assets/css/1.styles.295ecdc4.css" as="style"><link rel="preload" href="/assets/js/app.efdbb4a8.js" as="script"><link rel="preload" href="/assets/js/15.29717e3e.js" as="script"><link rel="prefetch" href="/assets/js/10.52f4905c.js"><link rel="prefetch" href="/assets/js/11.e87ebd5a.js"><link rel="prefetch" href="/assets/js/12.62e96062.js"><link rel="prefetch" href="/assets/js/13.977553d6.js"><link rel="prefetch" href="/assets/js/14.8736abec.js"><link rel="prefetch" href="/assets/js/16.fda07970.js"><link rel="prefetch" href="/assets/js/17.61e6ca33.js"><link rel="prefetch" href="/assets/js/18.52fed653.js"><link rel="prefetch" href="/assets/js/19.ac3a6699.js"><link rel="prefetch" href="/assets/js/2.1c57167a.js"><link rel="prefetch" href="/assets/js/20.1736de00.js"><link rel="prefetch" href="/assets/js/21.a802a0e2.js"><link rel="prefetch" href="/assets/js/22.20b545db.js"><link rel="prefetch" href="/assets/js/23.f96a04b7.js"><link rel="prefetch" href="/assets/js/24.38af72da.js"><link rel="prefetch" href="/assets/js/25.27f97d7f.js"><link rel="prefetch" href="/assets/js/26.1671aa90.js"><link rel="prefetch" href="/assets/js/27.2fed06ac.js"><link rel="prefetch" href="/assets/js/28.1e156ab6.js"><link rel="prefetch" href="/assets/js/29.8cd77d02.js"><link rel="prefetch" href="/assets/js/3.508cc7ad.js"><link rel="prefetch" href="/assets/js/30.c19e4ae3.js"><link rel="prefetch" href="/assets/js/31.1827f31f.js"><link rel="prefetch" href="/assets/js/32.6a2da8f3.js"><link rel="prefetch" href="/assets/js/33.aab4a7bf.js"><link rel="prefetch" href="/assets/js/34.cee0531c.js"><link rel="prefetch" href="/assets/js/35.964e4635.js"><link rel="prefetch" href="/assets/js/36.a5be6eb9.js"><link rel="prefetch" href="/assets/js/37.ad091423.js"><link rel="prefetch" href="/assets/js/38.9daab2b6.js"><link rel="prefetch" href="/assets/js/39.7227c324.js"><link rel="prefetch" href="/assets/js/4.fa721afa.js"><link rel="prefetch" href="/assets/js/40.e35a82bf.js"><link rel="prefetch" href="/assets/js/41.2ee2350c.js"><link rel="prefetch" href="/assets/js/42.d09d05da.js"><link rel="prefetch" href="/assets/js/5.bdfc79bb.js"><link rel="prefetch" href="/assets/js/6.8990a9d0.js"><link rel="prefetch" href="/assets/js/7.2d6f7576.js"><link rel="prefetch" href="/assets/js/8.988240f6.js"><link rel="prefetch" href="/assets/js/9.f41768b3.js">
    <link rel="stylesheet" href="/assets/css/1.styles.295ecdc4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="global-container"><div class="head-container"><div class="head-content clearfix"><div class="head-logo"><a href="/"><img src="/meta/logo.png"> <!----></a></div> <div class="head-links"><div class="el-row"><div class="el-col el-col-24 el-col-xs-0 el-col-sm-24"><ul role="menubar" class="head-menu el-menu--horizontal el-menu" style="background-color:;"><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-s-home"></i>
                            Index
                        </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-search"></i>
                            Search
                        </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-info"></i>
                            About
                        </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-link"></i>
                            Links
                        </li></ul></div> <div class="el-col el-col-24 el-col-xs-24 el-col-sm-0"><ul role="menubar" class="head-menu el-menu--horizontal el-menu" style="background-color:;"><li role="menuitem" aria-haspopup="true" class="head-menu-sub el-submenu"><div class="el-submenu__title" style="border-bottom-color:transparent;color:;background-color:;">Menu<i class="el-submenu__icon-arrow el-icon-arrow-down"></i></div><div class="el-menu--horizontal" style="display:none;"><ul role="menu" class="el-menu el-menu--popup el-menu--popup-" style="background-color:;"> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;background-color:;"><i class="el-icon-s-home"></i>
                                Index
                            </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;background-color:;"><i class="el-icon-search"></i>
                                Search
                            </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;background-color:;"><i class="el-icon-info"></i>
                                About
                            </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;background-color:;"><i class="el-icon-link"></i>
                                Links
                            </li></ul></div></li></ul></div></div></div></div></div> <div class="post-container component-content component-hide"><div class="post-title">Java 集合与容器类</div> <div class="post-tag"><a href="/search/Java"><i class="el-icon-paperclip"></i>
            Java
        </a></div> <div class="post-desc">集合与容器类是 Java 开发过程中的重要内容，是由接口、抽象类、派生类及相关算法组成的体系</div> <div class="markdown-content content__default"><h1 id="java-集合与容器类"><a href="#java-集合与容器类" class="header-anchor">#</a> Java 集合与容器类</h1> <h2 id="体系"><a href="#体系" class="header-anchor">#</a> 体系</h2> <p>早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack 和 Properties 这些类用来存储和操作对象组。虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。为此，整个集合框架就围绕一组标准接口而设计。</p> <p>集合框架被设计成要满足以下几个目标。</p> <ul><li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li> <li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li> <li>对一个集合的扩展和适应必须是简单的。</li></ul> <div class="language-mermaid extra-class"><pre class="language-text"><code>graph LR
	Collection接口--&gt;List接口
	Map接口--&gt;HashMap类
	Collection接口--&gt;Set接口
	List接口--&gt;ArrayList类
	List接口--&gt;LinkedList类
	Set接口--&gt;HashSet类
	Set接口--&gt;SortedSet类
	Map接口--&gt;SortedMap类
	SortedMap类--&gt;TreeMap类
	HashSet类--&gt;LinkedHashSet类
	SortedSet类--&gt;Treeset类
	Iterator接口--&gt;ListIterator接口

</code></pre></div><h2 id="接口"><a href="#接口" class="header-anchor">#</a> 接口</h2> <h3 id="collection"><a href="#collection" class="header-anchor">#</a> Collection</h3> <ol><li><p>最基本的集合接口，存储一组不唯一、无序的对象</p></li> <li><p>公共方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">int size()</td> <td style="text-align:center;">返回元素个数</td></tr> <tr><td style="text-align:center;">boolean isEmpty()</td> <td style="text-align:center;">判断是否为空</td></tr> <tr><td style="text-align:center;">boolean contains(Object obj)</td> <td style="text-align:center;">判断是否包含 obj</td></tr> <tr><td style="text-align:center;">boolean add(E element)</td> <td style="text-align:center;">添加元素，返回成功与否</td></tr> <tr><td style="text-align:center;">int hashCode()</td> <td style="text-align:center;">返回哈希码</td></tr> <tr><td style="text-align:center;">Object[] toArray()</td> <td style="text-align:center;">转换为 Object 数组</td></tr> <tr><td style="text-align:center;">boolean remove(Object obj)</td> <td style="text-align:center;">删除元素</td></tr> <tr><td style="text-align:center;">void clear()</td> <td style="text-align:center;">清空容器</td></tr> <tr><td style="text-align:center;">Iterator<E> iterator</E></td> <td style="text-align:center;">返回迭代器</td></tr> <tr><td style="text-align:center;">boolean equals(Object o)</td> <td style="text-align:center;">是否与 o 相等</td></tr> <tr><td style="text-align:center;">void shuffle(List&lt; ? &gt; list)</td> <td style="text-align:center;">随机重排元素</td></tr> <tr><td style="text-align:center;">boolean containsAll(Collection&lt; ? &gt; c)</td> <td style="text-align:center;">判断是否包含 c 中所有元素</td></tr> <tr><td style="text-align:center;">boolean addAll(Contain&lt; ? &gt; c)</td> <td style="text-align:center;">集合并运算</td></tr> <tr><td style="text-align:center;">boolean removeAll(Collection&lt; ? &gt; c)</td> <td style="text-align:center;">集合差运算</td></tr> <tr><td style="text-align:center;">boolean retainAll(Collection&lt; ? &gt; c)</td> <td style="text-align:center;">集合交运算，只保留也被 c 包含的元素</td></tr></tbody></table></li></ol> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <ol><li><p>存储键值对，提供 key 到 value 的映射，key 唯一</p></li> <li><p>公共方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">V put(K key,V value)</td> <td style="text-align:center;">插入键值对</td></tr> <tr><td style="text-align:center;">void putAll(Map&lt;? extends K,? extends V&gt; m)</td> <td style="text-align:center;">复制映射</td></tr> <tr><td style="text-align:center;">boolean containsKey(Object key)</td> <td style="text-align:center;">判断是否包含 key</td></tr> <tr><td style="text-align:center;">boolean containsValue(Object value)</td> <td style="text-align:center;">判断是否包含 value</td></tr> <tr><td style="text-align:center;">V get(Object key)</td> <td style="text-align:center;">返回键对应值</td></tr> <tr><td style="text-align:center;">Set<K> keySet()</K></td> <td style="text-align:center;">返回键的集合</td></tr> <tr><td style="text-align:center;">Collection<V> values()</V></td> <td style="text-align:center;">返回值的集合</td></tr> <tr><td style="text-align:center;">V remove(Object key)</td> <td style="text-align:center;">删除 key 对应条目</td></tr> <tr><td style="text-align:center;">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td> <td style="text-align:center;">返回键值对的集合</td></tr></tbody></table> <blockquote><p>使用 keySet() 抽取 key 序列，将 map 中的所有 key 生成一个 Set。</p> <p>使用 values() 抽取 value 序列，将 map 中的所有 values 生成一个 Collection。</p> <p>为什么一个生成 Set，一个生成 Collection？那是因为，key 总是独一无二的，value 允许重复。</p></blockquote></li></ol> <h3 id="list"><a href="#list" class="header-anchor">#</a> List</h3> <ol><li><p>Collection 的子接口，通过索引访问元素，存储一组不唯一、有序的对象</p></li> <li><p>公共方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">E get(int index)</td> <td style="text-align:center;">返回指定位置元素</td></tr> <tr><td style="text-align:center;">E set(int index,E element)</td> <td style="text-align:center;">替换指定位置，返回被取代元素</td></tr> <tr><td style="text-align:center;">int indexOf(Object o)</td> <td style="text-align:center;">返回 o 首次出现序号，不存在返回 -1</td></tr> <tr><td style="text-align:center;">int lastIndexOf(Object o)</td> <td style="text-align:center;">返回 o 最后出现序号</td></tr> <tr><td style="text-align:center;">void add(int index,E element)</td> <td style="text-align:center;">指定位置插入</td></tr> <tr><td style="text-align:center;">boolean add(E element)</td> <td style="text-align:center;">最后位置插入</td></tr> <tr><td style="text-align:center;">E remove(int index)</td> <td style="text-align:center;">删除并返回指定位置元素</td></tr> <tr><td style="text-align:center;">boolean addAll(Collection&lt;? extends E&gt; c)</td> <td style="text-align:center;">列表最后添加 c 中所有元素</td></tr> <tr><td style="text-align:center;">boolean addAll(int index,Collection&lt;? extends E&gt; c)</td> <td style="text-align:center;">指定位置添加 c 中所有元素</td></tr> <tr><td style="text-align:center;">ListIterator<E> listIterator()</E></td> <td style="text-align:center;">返回迭代器</td></tr> <tr><td style="text-align:center;">ListIterator<E> listIterator(int index)</E></td> <td style="text-align:center;">返回指定位置开始的迭代器</td></tr></tbody></table></li></ol> <h3 id="set"><a href="#set" class="header-anchor">#</a> Set</h3> <ol><li>Collection 的子接口，不保存重复元素，存储一组唯一、无序的对象</li> <li>公共方法：继承自 Collection，未声明其他方法，不提供 get 方法获取元素</li></ol> <h2 id="实现类"><a href="#实现类" class="header-anchor">#</a> 实现类</h2> <h3 id="list派生类"><a href="#list派生类" class="header-anchor">#</a> List派生类</h3> <ol start="2"><li><p>ArrayList</p> <ul><li><p>数组列表，自动扩容，增长长度为原来的 50%</p></li> <li><p>基于数组，随机访问、遍历效率高，插入删除效率低</p></li> <li><p>可插入 null</p></li></ul></li> <li><p>LiinkedList</p> <ul><li><p>链式数据结构</p></li> <li><p>基于双向链表，插入删除效率高，随机访问、查找效率低</p></li> <li><p>可插入 null</p></li> <li><p>常用方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">public void addFirst(E e)</td> <td style="text-align:center;">插入开头</td></tr> <tr><td style="text-align:center;">public void addLast(E e)</td> <td style="text-align:center;">插入尾部</td></tr> <tr><td style="text-align:center;">public E getFirst()</td> <td style="text-align:center;">返回第一元素</td></tr> <tr><td style="text-align:center;">public E getLast()</td> <td style="text-align:center;">返回最后元素</td></tr> <tr><td style="text-align:center;">public E removeFirst()</td> <td style="text-align:center;">删除并返回第一元素</td></tr> <tr><td style="text-align:center;">public E removeLast()</td> <td style="text-align:center;">删除并返回最后元素</td></tr></tbody></table></li></ul></li></ol> <h3 id="map派生类"><a href="#map派生类" class="header-anchor">#</a> Map派生类</h3> <ol><li><p>HashMap</p> <ul><li>查找元素的时间复杂度 O(1)</li> <li>允许 null 键和 null 值</li> <li>键必须唯一，值可以重复，无序</li> <li>上座率：元素个数达到容量与上座率乘积时，容量自动翻倍</li></ul></li> <li><p>TreeMap</p> <ul><li><p>基于二叉搜索树，查找元素时间复杂度 O(logn)</p></li> <li><p>实现了 SortedMap 接口</p></li> <li><p>不允许 null 键（空指针异常），允许 null 值</p></li> <li><p>键必须唯一，值可以重复，按键值从大到小排列</p></li> <li><p>常用方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">public K firstKey()</td> <td style="text-align:center;">返回最低键</td></tr> <tr><td style="text-align:center;">public K lastKey()</td> <td style="text-align:center;">返回最高键</td></tr> <tr><td style="text-align:center;">public SortedMap&lt;K,V&gt; headMap(K toKey)</td> <td style="text-align:center;">返回键值小于 toKey 那部分映射</td></tr> <tr><td style="text-align:center;">public SortedMap&lt;K,V&gt; tailMap(K toKey)</td> <td style="text-align:center;">返回大于等于 toKey 那部分映射</td></tr> <tr><td style="text-align:center;">public K lowerKey(K key)</td> <td style="text-align:center;">返回小于给定键的最大键</td></tr> <tr><td style="text-align:center;">public K floorKey(K key)</td> <td style="text-align:center;">返回小于等于给定键的最大键</td></tr> <tr><td style="text-align:center;">public K higherKey(K key)</td> <td style="text-align:center;">返回大于给定键的最小键</td></tr> <tr><td style="text-align:center;">public K ceilingKey(K key)</td> <td style="text-align:center;">返回大于等于给定键的最小键</td></tr></tbody></table></li></ul></li></ol> <h3 id="set派生类"><a href="#set派生类" class="header-anchor">#</a> Set派生类</h3> <ol><li><p>HashSet</p> <ul><li><p>内部封装了一个 HashMap，HashSet 作为 map 的 key 而存在，value 则是一个类属性</p></li> <li><p>允许 null 元素</p></li> <li><p>不能添加重复元素，方法添加重复对象时不改变集合返回 false</p></li> <li><p>无序，不按插入顺序，也不按 HashCode 顺序</p></li> <li><p>常用方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">public boolean add(E e)</td> <td style="text-align:center;">添加对象，返回成功与否</td></tr> <tr><td style="text-align:center;">public void clear()</td> <td style="text-align:center;">清空集合</td></tr> <tr><td style="text-align:center;">public boolean contains(Object o)</td> <td style="text-align:center;">判断是否包含 o 元素</td></tr> <tr><td style="text-align:center;">public int size()</td> <td style="text-align:center;">返回集合容量</td></tr></tbody></table></li></ul></li> <li><p>TreeSet</p> <ul><li>基于 TreeMap 的键实现，实现 了SortedSet 接口</li> <li>不允许插入 null 元素（空指针异常）</li> <li>按元素从小到大排序</li> <li>不能添加重复元素</li> <li>常用方法
|               方法               |           描述            |
| :------------------------------: | :-----------------------: |
|         public K first()         |       返回最低元素        |
|         public K last()          |       返回最高元素        |
| public SortedSet<E> headSet(E e) |   返回小于 e 那部分映射   |
| public SortedSet<E> tailSet(E e) | 返回大于等于 e 那部分映射 |
|       public E lower(E e)        |    返回小于 e 最大元素    |
|       public E floor(E e)        | 返回小于等于 e 的最大元素 |
|       public E higher(E e)       |   返回大于 e 的最小元素   |
|      public E ceiling(E e)       | 返回大于等于 e 的最小元素 |</E></E></li></ul></li> <li><p>LinkedHashset</p> <ul><li><p>继承自 HashMap，内部加入链表保存元素顺序</p></li> <li><p>基于元素进入集合的顺序或者被访问的顺序排序</p></li></ul></li></ol> <h3 id="传统类"><a href="#传统类" class="header-anchor">#</a> 传统类</h3> <ol><li><p>HashTable</p> <ul><li>Dictionary 的子类，实现了 Map 接口</li> <li>不允许 null 键，不允许 null 值</li> <li>键必须唯一，值可以重复，无序</li> <li>线程安全，支持同步</li></ul></li> <li><p>Vector</p> <ul><li>线程安全，同步访问</li> <li>继承自 AbstractList</li></ul></li> <li><p>Properties</p> <ul><li><p>继承自 HashTable，实现了 Map 接口</p></li> <li><p>表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串</p></li> <li><p>常用方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">String getProperty(String key)</td> <td style="text-align:center;">返回指定键对应属性</td></tr> <tr><td style="text-align:center;">Object setProperty(String key, String value)</td> <td style="text-align:center;">调用 Hashtable 的 put 方法</td></tr> <tr><td style="text-align:center;">void list(PrintStream streamOut)</td> <td style="text-align:center;">将属性列表输出到指定的输出流</td></tr> <tr><td style="text-align:center;">void list(PrintWriter streamOut)</td> <td style="text-align:center;">将属性列表输出到指定的输出流</td></tr> <tr><td style="text-align:center;">void load(InputStream streamIn) throws IOException</td> <td style="text-align:center;">从输入流中读取属性列表</td></tr></tbody></table> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//加载 properties 配置文件的两种方法,JDBCUtils 为例</span>
<span class="token comment">//方法一</span>
<span class="token class-name">URL</span> res <span class="token operator">=</span> <span class="token class-name">JDBCUtils</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">&quot;jdbc.properties&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> path <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pro<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token class-name">URLDecoder</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token string">&quot;utf-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//方法二</span>
<span class="token comment">// InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);</span>
<span class="token class-name">InputStream</span> is <span class="token operator">=</span> <span class="token class-name">JDBCUtils</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">&quot;/jdbc.properties&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pro<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p>Stack</p> <ul><li><p>继承自 Vector ，先进后出</p></li> <li><p>线程安全</p></li> <li><p>常用方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">boolean empty()</td> <td style="text-align:center;">判断是否栈空</td></tr> <tr><td style="text-align:center;">Object peek()</td> <td style="text-align:center;">查看栈顶元素，不删除</td></tr> <tr><td style="text-align:center;">Object pop()</td> <td style="text-align:center;">删除栈顶元素，并返回</td></tr> <tr><td style="text-align:center;">Object push(Object element)</td> <td style="text-align:center;">元素压栈</td></tr> <tr><td style="text-align:center;">int search(Object element)</td> <td style="text-align:center;">返回位置，以 1 为基数</td></tr></tbody></table></li></ul></li> <li><p>Dictionary</p> <ul><li>抽象类，用来存储键/值对，作用和Map类相似</li></ul></li> <li><p>BitSet</p> <ul><li><p>位集合， 按需增长的位向量</p></li> <li><p>使用场景：整数，无重复</p></li> <li><p>每一位的值都是一个 boolean 值 ，占用一 bit（不是一字节）</p></li> <li><p>内部基于 long 数组， 所以 BitSet 的大小为 long 类型大小(64位)的整数倍</p></li> <li><p>常用方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">void set(int index)</td> <td style="text-align:center;">将指定索引处的位设置为 true</td></tr> <tr><td style="text-align:center;">void set(int index, boolean v)</td> <td style="text-align:center;">将指定索引处的位设置为指定值</td></tr> <tr><td style="text-align:center;">void set(int startIndex, int endIndex)</td> <td style="text-align:center;">将范围内的位设置为 true（左开右闭）</td></tr></tbody></table></li></ul> <p>| void set(int startIndex, int endIndex, boolean v) | 将范围内的位设置为指定值（左开右闭） |
|              boolean get(int index)               |         返回指定索引处的位值         |</p></li></ol> <h2 id="算法"><a href="#算法" class="header-anchor">#</a> 算法</h2> <h3 id="collections"><a href="#collections" class="header-anchor">#</a> Collections</h3> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">Collections.reverse(List l)</td> <td style="text-align:center;">反转</td></tr> <tr><td style="text-align:center;">Collections.shuffle(List l)</td> <td style="text-align:center;">混淆</td></tr> <tr><td style="text-align:center;">Collections.sort(List l）</td> <td style="text-align:center;">排序</td></tr> <tr><td style="text-align:center;">Collections.swap(List l,int index1,int index2)</td> <td style="text-align:center;">替换下标位置元素</td></tr> <tr><td style="text-align:center;">Collections.rotate(List l,int step)</td> <td style="text-align:center;">向右滚动 ，尾部移动到开头</td></tr> <tr><td style="text-align:center;">Collections.synchronizedList()</td> <td style="text-align:center;">线程安全化</td></tr> <tr><td style="text-align:center;">Collections.fill(List l,Object o)</td> <td style="text-align:center;">填充</td></tr> <tr><td style="text-align:center;">Collections.copy(List m,List n)</td> <td style="text-align:center;">n 中的元素复制到 m 中，并覆盖相应索引的元素</td></tr></tbody></table> <h3 id="迭代器"><a href="#迭代器" class="header-anchor">#</a> 迭代器</h3> <ol><li><p>Collection 定义了 toArray()、iterator()、size()方法，但并非所有实现类都重写了这些方法，Set 不提供 get 方法，不能使用 size() 方式遍历。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//Set 遍历方式</span>
<span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//迭代器遍历</span>
<span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> it <span class="token operator">=</span> set<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  <span class="token class-name">String</span> str <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//for循环遍历：</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> str <span class="token operator">:</span> set<span class="token punctuation">)</span> 
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div></li> <li><p>Iterator 接口常用方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">public abstract boolean hasNext()</td> <td style="text-align:center;">判断是否还有后续元素</td></tr> <tr><td style="text-align:center;">public abstract E next()</td> <td style="text-align:center;">返回后续元素</td></tr> <tr><td style="text-align:center;">public abstract void remove()</td> <td style="text-align:center;">删除当前指向元素</td></tr></tbody></table></li> <li><p>ListIterator 接口常用方法</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">public abstract boolean hashPrevious()</td> <td style="text-align:center;">判断是否有前驱元素</td></tr> <tr><td style="text-align:center;">public abstract E previous()</td> <td style="text-align:center;">返回前驱元素</td></tr> <tr><td style="text-align:center;">public abstract add(E e)</td> <td style="text-align:center;">插入 next() 返回值之前，previoous() 之后</td></tr> <tr><td style="text-align:center;">public abstract set(E e)</td> <td style="text-align:center;">替换当前指向元素</td></tr> <tr><td style="text-align:center;">public abstract int nextIndex()</td> <td style="text-align:center;">返回基于 next() 元素序号</td></tr> <tr><td style="text-align:center;">public abstract int previousIndex()</td> <td style="text-align:center;">返回基于 previous() 元素序号</td></tr></tbody></table></li></ol> <h3 id="比较器"><a href="#比较器" class="header-anchor">#</a> 比较器</h3> <ol><li>Comparator类：一个类有多个属性，不知道按哪个属性进行排序时，通过 Comparator 类重写 compare(Object o1,Object o2 )指定比较算法，再利用 Collections.sort(List l,Comparator c) 进行排序</li> <li>Comparable接口：实现接口，重写 compareTO(Object another) 方法，利用 Collections.sort(List l）排序</li></ol> <h3 id="arrays"><a href="#arrays" class="header-anchor">#</a> Arrays</h3> <ol><li><p>数组复制</p> <ol><li><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">,</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOfRange</span><span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">)</span>
</code></pre></div><p>original：原数组	from：原数组的起始位置	to：终点位置（不包括）</p></li> <li><div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> newLength<span class="token punctuation">)</span>
</code></pre></div><p>original：原数组	newLength：要复制的长度</p> <blockquote><p>StringBuider 中底层数组的扩容使用了 copyOf()</p> <p>copyOf() 内部是通过 System.arraycopy() 实现的</p></blockquote></li> <li><div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span><span class="token class-name">Object</span> src<span class="token punctuation">,</span> <span class="token keyword">int</span> srcPos<span class="token punctuation">,</span> <span class="token class-name">Object</span> dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span>
</code></pre></div><p>src：原数组	srcPos：原数组起始位置</p> <p>dest：目标数组	destPost：目标数组的起始位置	length：复制长度</p> <blockquote><p>List 中的 remove 方法使用了 arraycopy()</p></blockquote></li></ol></li> <li><p>其他方法</p></li></ol> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td style="text-align:center;">public static String toString()</td> <td style="text-align:center;">转换为字符串</td></tr> <tr><td style="text-align:center;">public static void sort()</td> <td style="text-align:center;">排序</td></tr> <tr><td style="text-align:center;">public static int binarySearch(Object[] a, Object key )</td> <td style="text-align:center;">搜索</td></tr> <tr><td style="text-align:center;">public static boolean equals(long[] a, long[] b)</td> <td style="text-align:center;">判断是否相同</td></tr> <tr><td style="text-align:center;">public static void fill(int[] a, int val))</td> <td style="text-align:center;">填充</td></tr></tbody></table> <h3 id="hashcode"><a href="#hashcode" class="header-anchor">#</a> HashCode</h3> <blockquote><p>哈希集合查找元素为时间复杂度为 O(1) 的原理</p></blockquote> <ol><li><p>获得散列值：</p> <p>通过特定的哈希函数，每个对象都有对应的哈希值、</p></li> <li><p>hashcode对应到内存地址：</p> <p>可以使用一个数组 array，将要存的数据放在 array[hashcode] 位置上</p></li> <li><p>哈希碰撞</p> <p>通过哈希方法，两个不同的元素，获得了相同的哈希值</p> <p>最常用用的解决办法是拉链法，在同一地址上建立链表来存储多个 hashcode 相同的元素</p></li> <li><p>查找</p> <p>通过哈希值找到地址，若地址上有多个元素，则用 equals 判断存储位置是否相同</p> <blockquote><p>对于哈希集合来说，如果重写了元素对应的 equals() 方法或 hashcode() 方法中的一个，也必须重写另一个</p></blockquote></li></ol></div> <div class="catalog-container" style="display:none;"><!----> <div class="catalog-open"><i class="el-icon-s-operation"></i></div></div></div> <div class="foot-container"><div class="foot-links"><a href="https://github.com/cadecode" target="_blank">
            Github
        </a><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=eBsZHB0bFxwdOB4XABUZERRWGxcV" target="_blank">
            Email
        </a><a href="https://www.cnblogs.com/pgjett" target="_blank">
            Cnblogs
        </a></div> <div class="foot-meta"><p>Copyright © 2020 CadeCode</p> <p>
            Theme
            <a href="https://github.com/cadecode/vuepress-theme-2zh" target="_blank">2zh</a>
            powered by
            <a href="https://www.vuepress.cn/" target="_blank">vuepress</a></p></div></div> <div class="backtop-container" style="display:none;"><i class="el-icon-caret-top"></i></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.efdbb4a8.js" defer></script><script src="/assets/js/15.29717e3e.js" defer></script>
  </body>
</html>
