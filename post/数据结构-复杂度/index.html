<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构-复杂度 | CadeCode</title>
    <meta name="generator" content="VuePress 1.5.3">
    <link rel="icon" href="/meta/favicon.ico">
    <link rel="alternate" type="application/rss+xml" href="https://cadecode.github.io/ /rss.xml" title=" RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="https://cadecode.github.io/ /feed.atom" title=" Atom Feed">
    <link rel="alternate" type="application/json" href="https://cadecode.github.io/ /feed.json" title=" JSON Feed">
    <meta name="description" content="数据结构复杂度相关概念及分析方法">
    <link rel="preload" href="/assets/css/1.styles.497d8624.css" as="style"><link rel="preload" href="/assets/js/app.b7f5e02a.js" as="script"><link rel="preload" href="/assets/js/7.a189ee70.js" as="script"><link rel="prefetch" href="/assets/js/10.873b9d6a.js"><link rel="prefetch" href="/assets/js/11.d9a2adb4.js"><link rel="prefetch" href="/assets/js/12.88f2434d.js"><link rel="prefetch" href="/assets/js/13.0bd727ae.js"><link rel="prefetch" href="/assets/js/14.dae2922c.js"><link rel="prefetch" href="/assets/js/15.3240a04e.js"><link rel="prefetch" href="/assets/js/16.1cc2c525.js"><link rel="prefetch" href="/assets/js/17.9a779572.js"><link rel="prefetch" href="/assets/js/18.d1e88a7d.js"><link rel="prefetch" href="/assets/js/19.0841dc84.js"><link rel="prefetch" href="/assets/js/2.92ec88aa.js"><link rel="prefetch" href="/assets/js/20.ce510449.js"><link rel="prefetch" href="/assets/js/21.f301cf2b.js"><link rel="prefetch" href="/assets/js/22.d247785e.js"><link rel="prefetch" href="/assets/js/23.1aa956b4.js"><link rel="prefetch" href="/assets/js/24.78fbfcbf.js"><link rel="prefetch" href="/assets/js/25.b28b2005.js"><link rel="prefetch" href="/assets/js/26.19f2ef7f.js"><link rel="prefetch" href="/assets/js/27.5c473029.js"><link rel="prefetch" href="/assets/js/28.5649c3ee.js"><link rel="prefetch" href="/assets/js/29.12ed5822.js"><link rel="prefetch" href="/assets/js/3.c1d29a77.js"><link rel="prefetch" href="/assets/js/30.35616547.js"><link rel="prefetch" href="/assets/js/31.32f07264.js"><link rel="prefetch" href="/assets/js/32.b5ee2cf8.js"><link rel="prefetch" href="/assets/js/33.7dc78a50.js"><link rel="prefetch" href="/assets/js/34.727d881c.js"><link rel="prefetch" href="/assets/js/35.a6f84f58.js"><link rel="prefetch" href="/assets/js/36.63144512.js"><link rel="prefetch" href="/assets/js/37.df6e7d94.js"><link rel="prefetch" href="/assets/js/38.129aaebb.js"><link rel="prefetch" href="/assets/js/39.89d71789.js"><link rel="prefetch" href="/assets/js/4.bc2ec1eb.js"><link rel="prefetch" href="/assets/js/40.be6942b0.js"><link rel="prefetch" href="/assets/js/41.5a835b04.js"><link rel="prefetch" href="/assets/js/42.4964f71f.js"><link rel="prefetch" href="/assets/js/43.72d3207d.js"><link rel="prefetch" href="/assets/js/5.f313ae1f.js"><link rel="prefetch" href="/assets/js/6.34b4068a.js"><link rel="prefetch" href="/assets/js/8.014d1d04.js"><link rel="prefetch" href="/assets/js/9.7087f664.js">
    <link rel="stylesheet" href="/assets/css/1.styles.497d8624.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="global-container"><div class="head-container"><div class="head-content clearfix"><div class="head-logo"><a href="/"><img src="/meta/logo.png"> <!----></a></div> <div class="head-links"><div class="el-row"><div class="el-col el-col-24 el-col-xs-0 el-col-sm-24"><ul role="menubar" class="head-menu el-menu--horizontal el-menu" style="background-color:;"><li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-s-home"></i>
                            Index
                        </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-search"></i>
                            Search
                        </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-info"></i>
                            About
                        </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;border-bottom-color:transparent;background-color:;"><i class="el-icon-link"></i>
                            Links
                        </li></ul></div> <div class="el-col el-col-24 el-col-xs-24 el-col-sm-0"><ul role="menubar" class="head-menu el-menu--horizontal el-menu" style="background-color:;"><li role="menuitem" aria-haspopup="true" class="head-menu-sub el-submenu"><div class="el-submenu__title" style="border-bottom-color:transparent;color:;background-color:;">Menu<i class="el-submenu__icon-arrow el-icon-arrow-down"></i></div><div class="el-menu--horizontal" style="display:none;"><ul role="menu" class="el-menu el-menu--popup el-menu--popup-" style="background-color:;"> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;background-color:;"><i class="el-icon-s-home"></i>
                                Index
                            </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;background-color:;"><i class="el-icon-search"></i>
                                Search
                            </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;background-color:;"><i class="el-icon-info"></i>
                                About
                            </li> <li role="menuitem" tabindex="-1" class="el-menu-item" style="color:;background-color:;"><i class="el-icon-link"></i>
                                Links
                            </li></ul></div></li></ul></div></div></div></div></div> <div class="post-container component-content component-hide"><div class="post-title">数据结构-复杂度</div> <div class="post-tag"><a href="/search/DataStructure"><i class="el-icon-paperclip"></i>
            DataStructure
        </a></div> <div class="post-desc">数据结构复杂度相关概念及分析方法</div> <div class="markdown-content content__default"><h1 id="数据结构-复杂度"><a href="#数据结构-复杂度" class="header-anchor">#</a> 数据结构-复杂度</h1> <h2 id="复杂度分析"><a href="#复杂度分析" class="header-anchor">#</a> 复杂度分析</h2> <ol><li>数据结构和算法的目标：快、省，即执行效率和资源消耗</li> <li>“事后统计法”具有很大局限性，提前预估效率很重要</li> <li>复杂度分析是学习算法的精髓和分析算法的利器</li></ol> <h2 id="时间复杂度"><a href="#时间复杂度" class="header-anchor">#</a> 时间复杂度</h2> <ol><li>假设每行代码执行时间意义，所有代码的执行时间 <code>T(n)</code> 和每行代码的执行次数 <code>n</code> 成正比。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>T(n) = O (f(n))
</code></pre></div><ol start="2"><li>大O时间复杂度表示代码执行效率随数据规模增长的变化趋势，也叫<strong>渐进时间复杂度</strong>。</li> <li>当n很大时，低阶、常量、系数并不左右增长趋势，可以省略，只需要记录最大量级。</li></ol> <blockquote><ol><li>只关注循环次数最多的一段代码.</li> <li>加法法则：总复杂度等于量级最大的那一段代码。</li> <li>乘法法则：嵌套代码的复杂度等于内外代码复杂度之积。</li></ol></blockquote> <ol start="4"><li>常见复杂度量级
<ol><li>非多项式量级：$O(2^n),O(n!)$,称为NP算法，效率较低。</li> <li>多项式量级：$O(1),O(logn),O(n),O(nlogn),O(n^k)$。</li></ol></li></ol> <p>$O(1)$</p> <div class="language- extra-class"><pre class="language-text"><code>int i = 1 ;
int j = 2 ;
int sum = i + j ;
</code></pre></div><blockquote><p>常量级时间复杂度的表示方法，即便有 3 行，也是 O(1) ,并非 O(3) 。一般情况下，只要不存在循环、递归，复杂度都为 O(1) ，与代码量无关。</p></blockquote> <p>$O(logn)、O(nlogn)$</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    i <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>这段代码的复杂度为 $O(log_2n)$，不同底数的对数可以互相转换，系数可以省略，所以统一表示为 $O(logn)$。<br>
$O(nlogn)$ 表示把 $O(logn$) 的代码循环执行n遍。</p></blockquote> <p>$O(n+m)、O(n*m)$</p> <div class="language- extra-class"><pre class="language-text"><code>T1(n) + T2(m) = O (f(n) + g(m))
T1(n) * T2(m) = O (f(n) * g(m))
</code></pre></div><blockquote><p>当有多个数据规模，表示复杂度时不能省略。</p></blockquote> <hr> <h2 id="空间复杂度"><a href="#空间复杂度" class="header-anchor">#</a> 空间复杂度</h2> <ol><li>大 O 空间复杂度表示代码存储空间随数据规模增长的变化趋势</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li><code>int[] a = new int[n]</code>申请了大小为 n 的 int 类型数组，忽略常量阶的空间申请，所以上述代码空间复杂度为 O(n)。</li> <li>常见的空间复杂度有$O(1),O(n),O(n^2)$;</li></ol> <h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="header-anchor">#</a> 最好、最坏情况时间复杂度</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            p <span class="token operator">=</span> i <span class="token punctuation">;</span>
            <span class="token keyword">break</span> <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
    上述代码的作用是返回数组中 x 出现的位置。
    最好：第一个就是要找-&gt; O(1)
    最坏：遍历整个数组没有找到该元素-&gt; O(n)
**/</span>
</code></pre></div><ol><li>最好情况时间复杂度</li></ol> <blockquote><p>最理想情况下，执行这段代码的时间复杂度。</p></blockquote> <ol start="2"><li>最坏情况时间复杂度</li></ol> <blockquote><p>最糟糕情况下，执行这段代码的时间复杂度。</p></blockquote> <h2 id="平均时间复杂度"><a href="#平均时间复杂度" class="header-anchor">#</a> 平均时间复杂度</h2> <blockquote><p>分析上述代码，在长度为n的数组中查询x的位置，有 n+1 种情况，分别为数组的 <strong>0 到 n-1 位置</strong>上和<strong>不在数组中</strong>，把每种情况下，需要遍历的元素个数累加起来，除以 n+1 ，得到需要遍历元素个数的平均值。</p></blockquote> <p>$$
\frac{1+2+3+...+n+n}{n+1}\quad=\quad\frac{n(n+3)}{2(n+1)}
$$</p> <p>忽略常量、系数、低阶，简化后时间复杂度为O(n);结果虽然正确，但是这样计算没有考虑每种情况发生的概率，正确计算过程如下：
$$
1*\frac{1}{2n}+2*\frac{1}{2n}+...+n*\frac{1}{2n}+n*\frac{1}{2}=\frac{3n+1}{4}
$$
此结果是加权平均值，平均时间复杂度即加权平均时间复杂度，简化后得 O(n)。</p> <h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="header-anchor">#</a> 均摊时间复杂度</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span> 
  <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
      sum <span class="token operator">=</span> sum <span class="token operator">+</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">;</span>
    count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  array<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
  <span class="token operator">++</span>count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码实现了一个往数组中插入数据的功能。当数组满了之后，即 count == array.length 时，用 for 循环遍历数组求和，将求和之后的 sum 值放到数组的第一个位置，然后从第二个 位置开始插入数据。如果数组一开始就有空闲空间，则直接将数据插入数组</p> <p>分析以上代码，得出：</p> <ol><li>最好情况时间复杂度：有空闲位置，直接插入下标为 count 的位置，复杂度为 O(1)</li> <li>最坏情况时间复杂度：遍历数组，复杂度为 O(n)</li> <li>加权平均时间复杂度：有空闲位置 n 种情况，不空闲 1 种，概率都为$\frac{1}{n+1}$，加权平均时间复杂度为 O(1)</li></ol> <p>$$
1*\frac{1}{n+1}+1*\frac{1}{n+1}+...+n*\frac{1}{n+1}=&gt;O(1)
$$</p> <ol start="4"><li><p>均摊时间复杂度是用摊还分析法得出的：</p> <p>例如上述代码中，每一次 O(n) 的插入操作，都会紧跟 n-1 个 O(1) 的插入操作，把耗时多的操作均摊到接下来 O(1) 的操作上，那么这一组操作的均摊时间复杂度就是 O(1)</p> <blockquote><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们可以将这一组操作放在一起分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。</p> <p>在能够应用均摊时间复杂度分析的场合，<strong>一般均摊时间复杂度就等于最好情况时间复杂度</strong></p></blockquote></li></ol></div> <div class="catalog-container" style="display:none;"><!----> <div class="catalog-open"><i class="el-icon-s-operation"></i></div></div></div> <div class="foot-container"><div class="foot-links"><a href="https://cadecode.github.io/rss.xml" target="_blank">Rss</a> <a href="https://github.com/cadecode" target="_blank">
            Github
        </a><a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=eBsZHB0bFxwdOB4XABUZERRWGxcV" target="_blank">
            Email
        </a><a href="https://www.cnblogs.com/pgjett" target="_blank">
            Cnblogs
        </a></div> <div class="foot-meta"><p>Copyright © 2020 CadeCode</p> <p>
            Theme
            <a href="https://github.com/cadecode/vuepress-theme-2zh" target="_blank">2zh</a>
            powered by
            <a href="https://www.vuepress.cn/" target="_blank">vuepress</a></p> <p><a href="https://cadecode.github.io/sitemap.xml" target="_blank">Sitemap</a></p></div></div> <div class="backtop-container" style="display:none;"><i class="el-icon-caret-top"></i></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b7f5e02a.js" defer></script><script src="/assets/js/7.a189ee70.js" defer></script>
  </body>
</html>
