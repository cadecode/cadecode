---

title: Java 内存模型
date: 2020/2/24
description: 本文介绍计算机内存模型的含义、并发编程中原子性、可见性、有序性的基本概念，以及 Java 语言中内存模型即JMM 的实现方式
tag: Java 基础

---

# Java 内存模型

## 计算机内存模型

1. 当程序在运行过程中，会将运算需要的数据从主存复制一份到 CPU 的高速缓存当中，那么 CPU 进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中

2.  当 CPU 要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找  

3.  在 CPU 和主存之间增加缓存，在多线程场景下就可能存在**缓存一致性问题**，也就是说，在多核 CPU 中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致
4. 为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是**处理器优化**
5. 除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如 Java 虚拟机的即时编译器（JIT）也会做**指令重排**

## 并发编程特性

1. **原子性**是指在一个操作中就是 cpu 不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行
2. **可见性**是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
3. **有序性**即程序执行的顺序按照代码的先后顺序执行

## Java Memory Model

JMM 主要解决的问题： 解决由于多线程通过共享内存进行通信时，存在的**本地内存数据不一致**、**编译器会对代码指令重排序**、**处理器会对代码乱序执行**等带来的问题

- 缓存一致性问题就是**可见性**问题。
- 处理器优化是可以导致**原子性**问题
- 指令重排会导致**有序性**问题

## JMM 的实现

> 内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障

### 原子性

在 Java 中，为了保证原子性，提供了两个高级的字节码指令`monitorenter`和`monitorexit`。在 Java 中对应的关键字就是`synchronized`，在 Java 中可以使用`synchronized`来保证方法和代码块内的操作是原子性的

### 可见性

Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的

Java 中的`volatile`关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用`volatile`来保证多线程操作时变量的可见性

除了`volatile`，Java 中的`synchronized`和`final`两个关键字也可以实现可见性

### 有序性

在 Java 中，可以使用`synchronized`和`volatile`来保证多线程之间操作的有序性。实现方式有所区别：

- `volatile`关键字会禁止指令重排
- `synchronized`关键字保证同一时刻只允许一条线程操作