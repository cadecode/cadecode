---

title: 数据结构-复杂度
date: 2020/2/12
description: 本文介绍数据结构中复杂度的相关概念以及时间复杂度、空间复杂度、最好最坏时间复杂度、平均时间复杂度、均摊复杂度的分析方法
tag: 数据结构

---



# 数据结构-复杂度

## 复杂度分析

1. 数据结构和算法的目标：快、省，即执行效率和资源消耗
2. “事后统计法”具有很大局限性，提前预估效率很重要
3. 复杂度分析是学习算法的精髓和分析算法的利器


## 时间复杂度

1. 假设每行代码执行时间意义，所有代码的执行时间 `T(n)` 和每行代码的执行次数 `n` 成正比。

```
T(n) = O (f(n))
```

2. 大O时间复杂度表示代码执行效率随数据规模增长的变化趋势，也叫**渐进时间复杂度**。
3. 当n很大时，低阶、常量、系数并不左右增长趋势，可以省略，只需要记录最大量级。

> 1. 只关注循环次数最多的一段代码
> 2. 加法法则：总复杂度等于量级最大的那一段代码
> 3. 乘法法则：嵌套代码的复杂度等于内外代码复杂度之积

4. 常见复杂度量级
   1. 非多项式量级：$O(2^n),O(n!)$,称为NP算法，效率较低。
   2. 多项式量级：$O(1),O(logn),O(n),O(nlogn),O(n^k)$。

$O(1)$

```
int i = 1 ;
int j = 2 ;
int sum = i + j ;
```

>常量级时间复杂度的表示方法，即便有 3 行，也是 O(1) ,并非 O(3) 。一般情况下，只要不存在循环、递归，复杂度都为 O(1) ，与代码量无关

$O(logn)、O(nlogn)$

```java
int i = 1 ;
while ( i <= n )
{
    i = i * 2 ;
}
```

> 这段代码的复杂度为 $O(log_2n)$，不同底数的对数可以互相转换，系数可以省略，所以统一表示为 $O(logn)$
> $O(nlogn)$ 表示把 $O(logn$) 的代码循环执行 n 遍

$O(n+m)、O(n*m)$

```
T1(n) + T2(m) = O (f(n) + g(m))
T1(n) * T2(m) = O (f(n) * g(m))
```

> 当有多个数据规模，表示复杂度时不能省略

---

## 空间复杂度

1. 大 O 空间复杂度表示代码存储空间随数据规模增长的变化趋势

```java
void print(int n) 
{
    int i = 0;
    int[] a = new int[n];
    for (i; i <n; ++i) 
    {
        a[i] = i * i;
    }
}
```

2. `int[] a = new int[n]`申请了大小为 n 的 int 类型数组，忽略常量阶的空间申请，所以上述代码空间复杂度为 O(n)。
3. 常见的空间复杂度有$O(1),O(n),O(n^2)$;

## 最好、最坏情况时间复杂度

```java
public int find(int[] array,int n,int x)
{
    int p = -1 ;
    for(int i = 0 ; i < n ; ++i)
    {
        if(array[i] == x)
        {
            p = i ;
            break ;
        }
    }
    return p ;
}
/**
    上述代码的作用是返回数组中 x 出现的位置。
    最好：第一个就是要找-> O(1)
    最坏：遍历整个数组没有找到该元素-> O(n)
**/
```

1. 最好情况时间复杂度

>最理想情况下，执行这段代码的时间复杂度。

2. 最坏情况时间复杂度

>最糟糕情况下，执行这段代码的时间复杂度。

## 平均时间复杂度

>分析上述代码，在长度为 n 的数组中查询 x 的位置，有 n+1 种情况，分别为数组的 **0 到 n-1 位置**上和**不在数组中**，把每种情况下，需要遍历的元素个数累加起来，除以 n+1 ，得到需要遍历元素个数的平均值。

$$
\frac{1+2+3+...+n+n}{n+1}\quad=\quad\frac{n(n+3)}{2(n+1)}
$$

忽略常量、系数、低阶，简化后时间复杂度为O(n);结果虽然正确，但是这样计算没有考虑每种情况发生的概率，正确计算过程如下：
$$
1*\frac{1}{2n}+2*\frac{1}{2n}+...+n*\frac{1}{2n}+n*\frac{1}{2}=\frac{3n+1}{4}
$$
此结果是加权平均值，平均时间复杂度即加权平均时间复杂度，简化后得 O(n)。

## 均摊时间复杂度

```java
int[] array = new int[n];
int count = 0;
void insert(int val) 
{
  if (count == array.length) 
  {
    int sum = 0;
    for (int i = 0; i < array.length; ++i) 
    {
      sum = sum + array[i];
    }
    array[0] = sum;
    count = 1;
  }
  array[count] = val;
  ++count;
}
```

这段代码实现了一个往数组中插入数据的功能。当数组满了之后，即 count == array.length 时，用 for 循环遍历数组求和，将求和之后的 sum 值放到数组的第一个位置，然后从第二个 位置开始插入数据。如果数组一开始就有空闲空间，则直接将数据插入数组

分析以上代码，得出：

1. 最好情况时间复杂度：有空闲位置，直接插入下标为 count 的位置，复杂度为 O(1) 
2. 最坏情况时间复杂度：遍历数组，复杂度为 O(n) 
3. 加权平均时间复杂度：有空闲位置 n 种情况，不空闲 1 种，概率都为$\frac{1}{n+1}$，加权平均时间复杂度为 O(1) 

$$
1*\frac{1}{n+1}+1*\frac{1}{n+1}+...+n*\frac{1}{n+1}=>O(1)
$$

4. 均摊时间复杂度是用摊还分析法得出的：

   例如上述代码中，每一次 O(n) 的插入操作，都会紧跟 n-1 个 O(1) 的插入操作，把耗时多的操作均摊到接下来 O(1) 的操作上，那么这一组操作的均摊时间复杂度就是 O(1)

   > 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们可以将这一组操作放在一起分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。  
   >
   > 在能够应用均摊时间复杂度分析的场合，**一般均摊时间复杂度就等于最好情况时间复杂度**

