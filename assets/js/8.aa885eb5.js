(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{466:function(t,a,s){"use strict";s.r(a);var n=s(3),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"数据结构-排序算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-排序算法"}},[t._v("#")]),t._v(" 数据结构-排序算法")]),t._v(" "),s("h2",{attrs:{id:"基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("稳定排序")]),t._v(" "),s("p",[t._v("假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面，则这个排序算法是稳定的")])]),t._v(" "),s("li",[s("p",[t._v("原地排序")]),t._v(" "),s("p",[t._v("空间复杂度为 $O(1)$ 的排序算法")])])]),t._v(" "),s("h2",{attrs:{id:"比较类排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#比较类排序"}},[t._v("#")]),t._v(" 比较类排序")]),t._v(" "),s("h3",{attrs:{id:"交换排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#交换排序"}},[t._v("#")]),t._v(" 交换排序")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("冒泡排序")]),t._v(" "),s("p",[t._v("冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作")]),t._v(" "),s("p",[t._v("时间复杂度：$O(n^2)$")]),t._v(" "),s("p",[t._v("空间复杂度：$O(1)$")]),t._v(" "),s("p",[t._v("稳定性：相邻元素相等时不交换，则为稳定排序")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code")])])])]),t._v(" "),s("p",[t._v("function bubbleSort(nums) {\nlet temp\nlet flag = false // 使用标记位进行优化，没有数据可交换时停止循环\nfor (let i = 0; i < nums.length; i++) {\nflag = false\nfor (let j = 0; j < nums.length - 1 - i; j++) {\nif (nums[j] > nums[j + 1]) {\ntemp = nums[j]\nnums[j] = nums[j + 1]\nnums[j + 1] = temp\nflag = true\n}\n}\nif (flag) {\nbreak\n}\n}\n}")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("\n\n\n2. 快速排序\n\n如果要排序数组中下标 l 到 r 之间的数据，先选择 l 与 r 之间任意一个数据作为分区点 x，遍历 l 到 r 之间的数据，将大于 x 的放右边，小于 x 的放左边，再递归排序两部分，直到区间缩小位 1，则所有数据都完成排序\n\n时间复杂度：$O(nlogn)$\n\n空间复杂度：$O(logn)$，$log_2n$ 次递归\n\n稳定性：不稳定\n\n```javascript\nfunction quickSort(nums, l, r) {\n    if (l >= r) {\n        return\n    }\n    let i = l\n    let j = r\n    let x = nums[i]\n    while (i < j) {\n        while (i < j && x < nums[j]) {\n            j--\n        }\n        nums[i] = nums[j]\n        while (i < j && x > nums[i]) {\n            i++\n        }\n        nums[j] = nums[i]\n    }\n    nums[i] = x\n    quickSort(nums, l, i - 1)\n    quickSort(nums, i + 1, r)\n}\n")])])]),s("h3",{attrs:{id:"插入排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#插入排序"}},[t._v("#")]),t._v(" 插入排序")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("直接插入排序")]),t._v(" "),s("p",[t._v("将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区 间中元素为空，算法结束")]),t._v(" "),s("p",[t._v("时间复杂度：$O(n^2)$")]),t._v(" "),s("p",[t._v("空间复杂度：$O(1)$")]),t._v(" "),s("p",[t._v("稳定性：将后面的数据放到相等数据的后面，则为稳定排序")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("insertSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("nums")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" temp\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" j\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" nums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        temp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n        j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" nums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" temp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            nums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n            j"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        nums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" temp\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("希尔排序")])])]),t._v(" "),s("h3",{attrs:{id:"选择排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选择排序"}},[t._v("#")]),t._v(" 选择排序")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("简单选择排序")])]),t._v(" "),s("li",[s("p",[t._v("堆排序")])])]),t._v(" "),s("h3",{attrs:{id:"归并排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#归并排序"}},[t._v("#")]),t._v(" 归并排序")]),t._v(" "),s("h2",{attrs:{id:"非比较排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非比较排序"}},[t._v("#")]),t._v(" 非比较排序")]),t._v(" "),s("h3",{attrs:{id:"计数排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计数排序"}},[t._v("#")]),t._v(" 计数排序")]),t._v(" "),s("h3",{attrs:{id:"基数排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基数排序"}},[t._v("#")]),t._v(" 基数排序")]),t._v(" "),s("h3",{attrs:{id:"桶排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#桶排序"}},[t._v("#")]),t._v(" 桶排序")])])}),[],!1,null,null,null);a.default=r.exports}}]);