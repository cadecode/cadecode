(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{463:function(a,t,v){"use strict";v.r(t);var _=v(3),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"jvm-内存结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm-内存结构"}},[a._v("#")]),a._v(" JVM 内存结构")]),a._v(" "),v("div",{staticClass:"language-mermaid extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("graph TB\n\tA(jvm)--\x3eE(类加载器系统)\n\tA--\x3eB(运行时数据区)\n\tA--\x3eD(本地库接口)\n\tA--\x3eC(执行引擎)\n\tB--\x3e虚拟机栈\n\tB--\x3e本地方法栈\n\tB--\x3e堆区\n\tB--\x3e方法区\n\tB--\x3e程序计数器\n\t\n")])])]),v("h2",{attrs:{id:"运行时数据区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区"}},[a._v("#")]),a._v(" 运行时数据区")]),a._v(" "),v("blockquote",[v("p",[a._v("从整个计算机内存中开辟一块内存存储 jvm 运行时需要用到的对象，变量等")])]),a._v(" "),v("h3",{attrs:{id:"虚拟机栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈"}},[a._v("#")]),a._v(" 虚拟机栈")]),a._v(" "),v("ol",[v("li",[a._v("线程私有")]),a._v(" "),v("li",[a._v("服务于方法")]),a._v(" "),v("li",[a._v("用于存储局部变量表、操作数栈、动态链接、方法出口等信息")])]),a._v(" "),v("h3",{attrs:{id:"本地方法栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[a._v("#")]),a._v(" 本地方法栈")]),a._v(" "),v("ol",[v("li",[a._v("线程私有")]),a._v(" "),v("li",[a._v("为虚拟机调用 Native 方法服务")])]),a._v(" "),v("h3",{attrs:{id:"堆区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆区"}},[a._v("#")]),a._v(" 堆区")]),a._v(" "),v("ol",[v("li",[a._v("线程共享")]),a._v(" "),v("li",[a._v("存储对象实例，是虚拟机中内存最大的一块")]),a._v(" "),v("li",[a._v("分为年轻代、年老代、持久代（JDK8 中废弃），年轻代用来存放新对象，当对象存活时间够长时，移动到年老代")])]),a._v(" "),v("h3",{attrs:{id:"方法区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[a._v("#")]),a._v(" 方法区")]),a._v(" "),v("ol",[v("li",[a._v("线程共享")]),a._v(" "),v("li",[a._v("用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据")]),a._v(" "),v("li",[a._v("jdk7 及以往版本，方法区基于堆的永久代实现，理论上是堆的一部分")]),a._v(" "),v("li",[a._v("jdk8 取消了永久代，在本地内存中划分区域-元空间，不属于 JVM 内存，方法区位于元空间中")]),a._v(" "),v("li",[a._v("包括运行时常量池和 class 文件常量池")])]),a._v(" "),v("h3",{attrs:{id:"程序计数器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[a._v("#")]),a._v(" 程序计数器")]),a._v(" "),v("ol",[v("li",[a._v("线程私有")]),a._v(" "),v("li",[a._v("是当前线程所执行的字节码的行号指示器")]),a._v(" "),v("li",[a._v("字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令")]),a._v(" "),v("li",[a._v("分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成")])]),a._v(" "),v("h2",{attrs:{id:"执行引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行引擎"}},[a._v("#")]),a._v(" 执行引擎")]),a._v(" "),v("ol",[v("li",[a._v("解释器：解释执行经过编译后生成的字节码文件")]),a._v(" "),v("li",[a._v("即时编译器 JIT： 收集一些代码的执行信息（预热过程）之后，将频繁执行的代码（热点代码）直接编译成本地机器码")]),a._v(" "),v("li",[a._v("垃圾收集器：java 虚拟机自动进行内存管理，根据垃圾收集算法，清理无用对象")])]),a._v(" "),v("h2",{attrs:{id:"本地库接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#本地库接口"}},[a._v("#")]),a._v(" 本地库接口")]),a._v(" "),v("ol",[v("li",[a._v("本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++ 程序，Java 诞生的时候 C/C++ 横行，要想立足，必须可以调用 C/C++ 程序，于是就在内存中专门开辟了一块区域处理标记为 native 的代码")]),a._v(" "),v("li",[a._v("它的具体作法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库")]),a._v(" "),v("li",[a._v("目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机，或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等")])]),a._v(" "),v("h2",{attrs:{id:"类加载器系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载器系统"}},[a._v("#")]),a._v(" 类加载器系统")]),a._v(" "),v("ol",[v("li",[a._v("负责加载字节码文件，class 文件在文件开头有特定的文件标示，并且 ClassLoader 负责 class 文件的加载等，至于它是否可以运行，则由 Execution Engine 决定")]),a._v(" "),v("li",[a._v("主要功能\n"),v("ul",[v("li",[a._v("定位和导入二进制 class 文件")]),a._v(" "),v("li",[a._v("验证导入类的正确性")]),a._v(" "),v("li",[a._v("为类分配初始化内存")]),a._v(" "),v("li",[a._v("帮助解析符号引用")])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);